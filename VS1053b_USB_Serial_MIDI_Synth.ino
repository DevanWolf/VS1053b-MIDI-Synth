/**
 * Realime USB Serial MIDI Sound Module
 *
 * Turns your Arduino UNO into a fully working standalone USB/Serial General MIDI synth!
 *
 * Hardware:
 * - Arduino UNO (or compatible)
 * - VS1053b Module (e.g. Waveshare Music Shield)
 *
 * Pin Connections (Arduino UNO):
 * - MISO: Pin 12
 * - MOSI: Pin 11
 * - SCK: Pin 13
 * - DREQ: Pin A1
 * - XRST: Pin A0
 * - XCS: Pin A3
 * - XDCS: Pin A2
 *
 * Software:
 * - EA Serial MIDI Bridge (https://github.com/ezequielabregu/EA-serialmidi-bridge/releases)
 * or Hairless MIDI<->Serial (https://github.com/tyan0/hairless-midiserial/releases)
 * - loopMIDI (for Windows users) (https://tobias-erichsen.de/software/loopmidi.html)
 *
 * SysEx commands implemented and wrapped in this sketch:
 * FF - System Reset
 * F0 7E 7F 09 01 F7 - GM Reset
 * F0 7F 7F 04 01 xx vv F7 - Master Volume
 * F0 7F 7F 04 02 +x vv F7 - Master Balance
 * F0 00 01 11 01 0v F7 - EarSpeaker Setting
 * F0 00 01 11 02 bl th F7 - Bass & Treble Setting
 * F0 00 01 11 03 0v F7 - Reverb Setting
 *
 * Author: Sobble Entertainment Inc.
 */

#include <SPI.h>

// If you're using a different Arduino and/or a different music shield, change the below 4 pin IDs to their matching connections
#define XCS A3
#define XDCS A2
#define DREQ A1
#define XRESET A0

// Button definitions, remove one of the lines below to disable its function in case of different music shields without buttons (e.g. Sparkfun MP3 Shield, Adafruit Music Maker)
#define REVERB_TOGGLE 5 // mapped to Play/Pause button
#define RESET 6 // mapped to Left/Previous button
#define VOLUME_UP 3
#define VOLUME_DOWN 7

#define LED 8 // Remove this line to disable the panel activity LED

const word plg[] PROGMEM = {7,1,0x8050,6,0x03f0,0x2800,0x8080,6,0x2016,0xf400,0x4095,6,0x17,0x3009,0x1c40,0x3009,0x1fc2,0x6020,0x24,0,0x1fc2,0x2000,0,0xb020,0x4542,0x3613,0x24,6,0x57,0x3e15,0x1c15,0x20,0x1fd4,0x3580,0x3802,0xf204,0x3804,0x0fff,0xfe44,0xa244,0x1804,0xf400,0x4094,0x2800,0x1985,0x3009,0x1bc2,0xf400,0x4500,0x2000,0,0x36f5,0x3c15,0x3009,0x3857,0x2800,0x1b40,0x30,0x0457,0x3009,0x3857,0x30,0x0a57,0x3e14,0xf806,0x3701,0x8024,6,0x17,0x3e04,0x9c13,0x20,0x1fd2,0x3b81,0x8024,0x36f4,0xbc13,0x36f4,0xd806,0x30,0x0717,0x2100,0,0x3f05,0xdbd7,0x30,0xf80f,0,0x1f0e,0x2800,0x7680,0,0x4d,0xf400,0x4595,0x3e00,0x17cc,0x3505,0xf802,0x3773,0x24,0x3763,0x24,0x3700,0x24,0,0x09c2,0x6024,0x24,0x3600,0x1802,0x2830,0xf855,0,0x4d,0x2800,0x2240,0x36f3,0x24,0x3613,0x24,0x3e12,0xb817,0x3e12,0x3815,0x3e05,0xb814,0x3625,0x24,0,0x800a,0x3e10,0x3801,0x3e10,0xb803,0x3e11,0x3810,0x3e04,0x7812,0x34c3,0x24,0x3440,0x24,0x4080,0x24,0x1b,0x3301,0x2800,0x2c85,0,0x0180,0,0x0551,0,0xaf02,0x293c,0x1f40,7,0xffc1,0xb010,0x134c,0x18,1,0x4010,0x10d0,7,0xffc1,0xfe20,0x020c,0,0x0591,0x48b6,0x24,0x4dd6,0x24,1,0x2202,0x293c,0x1f40,0x4380,0x2003,0xb010,0x134c,0x18,1,0x4010,0x1010,0xfe20,0x020c,0x48b6,0x844c,0x4dd6,0x24,0xb880,0x2003,0x3434,0x24,0x2800,0x5280,0x3083,0x24,0x1c,0xccc2,0,0x05d1,0x34d3,0x24,0x3404,0x24,0x3404,0x420c,0x3001,0x05cc,0xa408,0x044c,0x3100,0x24,0x6010,0x24,0xfe20,0x24,0x48b6,0x24,0x4dd6,0x24,0x4310,0x24,0x4488,0x2400,0,0x0551,0x2800,0x3295,0x3404,0x24,0xf290,0xcc,0x3800,0x24,0x3434,0x24,0x3073,0x24,0x3013,0x24,0x2800,0x4340,0x3800,0x24,0x3083,0x24,0x3000,0x24,0x6402,0x24,0,0x1001,0x2800,0x3618,0x18,2,0x3434,0x4024,0x3133,0x24,0x3100,0x24,0xfe20,0x24,0x48b6,0x24,0x4dd6,0x24,0x2800,0x4340,0x3900,0xc024,0x4010,0x1011,0x6402,0x24,0,0x0590,0x2800,0x3918,0,0x24,0xf290,0x04cc,0x3900,0x24,0x3434,0x24,0x3073,0x24,0x3013,0x24,0x2800,0x4340,0x3800,0x24,0x3183,0x24,0x3100,0x24,0x6402,0x24,0,0x1001,0x2800,0x3c98,0x19,0x9982,0x3434,0x24,0x3033,0x24,0x3000,0x24,0xfe20,0x24,0x48b6,0x24,0x4dd6,0x24,0x2800,0x4340,0x3800,0xc024,0x4010,0x24,0x6402,0x24,0x1d,0x7082,0x2800,0x4198,0,0x24,0xf290,0x1010,0x3033,0x24,0x3800,0x24,0x3404,0x24,0x3073,0x24,0x3013,0x24,0x3800,0x24,4,0x4d50,0x3010,0x24,0x30f0,0x4024,0x3434,0x4024,0x3143,0x24,0x3910,0x24,0x2800,0x4340,0x39f0,0x4024,0x3434,0x24,0x3033,0x24,0x3000,0x24,0xfe20,0x24,0x48b6,0x24,0x4dd6,0x24,0x3800,0xc024,0x1e,0x9982,1,0x1012,0,0x0381,0x34d3,0x184c,0x3444,0x24,0x3073,0x24,0x3013,0x24,0x3000,0x24,0xfe20,0x24,0x48b6,0x24,0x4dd6,0x24,0x4380,0x3003,0x3400,0x24,0x293d,0x2900,0x3e00,0x24,0x3009,0x33c0,0x293b,0xc540,0x10,4,0x34d3,0x184c,0x3444,0x24,0x3073,0x13c0,0x3073,0x24,0x293b,0xf880,1,0x1011,1,0x10,1,0x1011,0x34d3,0x184c,0x3430,0x24,0x4010,0x24,0,0x05c1,0x3e10,0x24,0x293b,0xac80,6,0x92,0,0x05d1,0x36f3,0x134c,0x3404,0x24,0x3083,0x24,0x3000,0x24,0x6012,0x24,0x13,0x3304,0x2800,0x5198,1,0xc682,0,0x0500,1,0x12,0x3404,0x584c,0x3133,0x24,0x3100,0x4024,0,0x05d1,0xfe22,0x24,0x48b6,0x24,0x4dd6,0x24,0x3e10,0xc024,0x3430,0x8024,0x4204,0x24,0x293b,0xb580,0x3e00,0x8024,0x36e3,0x134c,0x3434,0x24,0x3083,0x24,0x3000,0x24,0x6090,0x24,0x3800,0x1812,0x36f4,0x4024,0x36f1,0x1810,0x36f0,0x9803,0x36f0,0x1801,0x3405,0x9014,0x36f3,0x24,0x36f2,0x1815,0x2000,0,0x36f2,0x9817,0x3613,0x24,0x3e12,0xb817,0x3e12,0x3815,0x3e05,0xb814,0x3615,0x24,0,0x800a,0x3e10,0x3801,0x3e10,0xb804,0x3e01,0x7810,8,0x04d0,0x2900,0x1480,0x3001,0x24,0x4080,0x03cc,0x3000,0x24,0x2800,0x7485,0x4090,0x24,0,0x24,0x2800,0x6245,0,0x24,0,0x81,0x3000,0x24,0x6012,0x24,0,0x0401,0x2800,0x70c5,0,0x24,0x6012,0x24,0,0x24,0x2800,0x6645,0,0x24,0x2900,0x1680,0,0x24,0x4088,0x8c,0,0x2000,0x6400,0x24,0,0x3c00,0x2800,0x5ed8,0,0x24,0x2800,0x6300,0x3801,0x24,0x6400,0x038c,0,0x24,0x2800,0x6318,0,0x24,0x3013,0x24,0x2900,0x1480,0x3801,0x24,0x4080,0x24,0,0x24,0x2800,0x6255,0,0x24,0x6890,0x03cc,0x2800,0x7480,0x3800,0x24,0x2900,0x1680,8,0x0510,0x3800,0x24,0,0x3c00,0x6400,0x24,0x3f,0xff00,0x2800,0x6b08,0,0x24,0,0x3fc0,0x6400,0x24,0,0x3c00,0x2800,0x73c5,0x6400,0x24,0,0x24,0x2800,0x73d5,0,0x24,0xb880,0x184c,0x2900,0x1480,0x3009,0x3800,0x4082,0x9bc0,0x6014,0x24,0,0x3c04,0x2800,0x6941,0,0x3dc1,0x2900,0x1680,0,0x24,0xf400,0x4004,0,0x3dc1,0x6412,0x24,8,0x0490,0x2800,0x6a85,0,0,0,0x0400,0x2800,0x7480,0x3800,0x24,8,0x04d0,0x3001,0x4024,0xa50a,0x24,0,0x03c0,0xb50a,0x24,0,0x0300,0x6500,0x24,0,0x24,0x2900,0x1488,0,0x6f48,0,0x0380,0x6500,0x24,0,0x24,0x2800,0x7195,0,0x24,0x2900,0x1480,0,0x24,0x4080,0x03cc,0,0x80,0x2800,0x70d5,0,0x24,0x2800,0x7480,0x3800,0x24,0x2900,0x1680,0,0x24,0x408a,0x24,8,0x0510,0x3613,0x24,0x3e11,0x4024,0x30f0,0x24,0x3e10,0x24,0x3000,0x4024,0x2931,0xe080,0x3e00,0x4024,0x36d3,0x24,0,0,8,0x0490,0x3800,0x24,0x36f1,0x5810,0x36f0,0x9804,0x36f0,0x1801,0x3405,0x9014,0x36f3,0x24,0x36f2,0x1815,0x2000,0,0x36f2,0x9817,5,0xbe51,1,0x10,0x3613,0x24,0x3e05,0xb814,0x3635,0x24,0,0x800a,0xb880,0x104c,0xb882,0x33c0,0x2914,0xbec0,4,0xc580,0x19,0x98c0,4,0x4e90,0x3800,0x24,0x1f,0xff00,0x2931,0x6c40,0x3900,0x24,0x2931,0x6640,0,0x24,0x2900,0x5500,0,0x8001,0x2912,0x0d00,0x3613,0x24,0x6012,0x24,0,0x8005,0x2800,0x7b18,4,0x4d50,0x2912,0x0d00,0x3613,0x108c,0x2934,0x4180,0x3ce0,0x24,0,0x1000,0x3423,0x24,0x2900,0x0a80,0x34e1,0x24,0xb882,0x42,0x30f0,0xc024,0x4dc2,0x24,0x3810,0x24,0x2800,0x7b00,0x38f0,0x4024,0x3e12,0xb817,0x3e12,0x3815,0x3e05,0xb814,0x3615,0x24,0,0x800a,0x3e10,0x3801,0,0x81,0xb880,0xb811,0x30,0x0291,0x3e14,0x24,0x30,0x0690,0x3e14,0xb813,0x30,0xd3,7,0x9252,0x3800,0x24,0x3910,0x24,0x3a00,0x24,0,0xc0c0,0x3900,0x24,0x30,0,6,0x51,0x2908,0x6400,0x3b00,0x24,0xb880,0x8c,0x3800,0x24,0x3800,0x24,3,0x0d40,6,0xc490,0x2908,0x7f80,0x3009,0x2000,0x30,0x0ad0,0x3800,0x184c,0x2b,0x1100,0x3e10,0x24,0x2909,0xa9c0,0x3e10,0x4024,0x0a,0x8001,0x2908,0x7f80,0x36e3,0x24,0xb880,0x2000,6,0x10,0x3009,0x2410,6,0x11,0x3009,0x2410,8,0x0490,0x3810,0x24,0x3800,0x24,0,0x0890,0x290f,0xfcc0,6,0x8380,0x0a,0x8001,0,0x0950,0x290f,0xfcc0,6,0xb380,0,0x09c0,0x30,0x0690,0x6890,0x2000,0x30,0x1310,0x6890,0x2000,0x30,0x0490,0x2900,0x1e00,0x3800,0x24,0x36f4,0x9813,0x36f4,0x1811,0x36f0,0x1801,0x3405,0x9014,0x36f3,0x24,0x36f2,0x1815,0x2000,0,0x36f2,0x9817,7,1,0x5800,6,4,0x1800,0x1800,0x98cc,0x7395,7,1,0x8025,6,2,0x2a00,0x1ace,7,1,0x8022,6,2,0x2a00,0x1a0e,0x0a,1,0x50}; // using full plugin for full support because the minimal plugin uses 4 note polyphony and no reverb
#define MAX_SYSEX_BYTES 6 // should not be changed unless you added more custom SysEx messages to the code yourself
byte cmd, volume, sysex[MAX_SYSEX_BYTES];
char value, balance;
#ifdef REVERB_TOGGLE
bool reverbOff, debounce;
#elif defined(RESET)
bool debounce;
#endif

void writeRegisterSplit(byte address, byte valueM, byte valueL) {
	digitalWrite(XCS, LOW);
	SPI.transfer(2);
	SPI.transfer(address);
	SPI.transfer(valueM);
	SPI.transfer(valueL);
	digitalWrite(XCS, HIGH);
}

void writeRegister(byte address, word value) {
	writeRegisterSplit(address, value >> 8, value & 0xFF);
}

void updateVolume() {
	writeRegisterSplit(0x0B, volume + max(balance, 0), volume + max(-balance, 0));
}

#if defined(VOLUME_UP) && defined(VOLUME_DOWN)
void volumeControl() {
		updateVolume();
#ifdef LED
		digitalWrite(LED, HIGH);
		delayMicroseconds(191 - volume << 6);
		digitalWrite(LED, LOW);
		delayMicroseconds(volume + 65 << 6);
#else
		delay(10);
#endif
}
#endif

void SPI_transfer8bit(byte data) {
	SPI.transfer(0);
	SPI.transfer(data);
}

void resetMIDI() {
	value = 0;
	balance = 0;
	writeRegisterSplit(0x0A, 0, 0x50);
}

void reset() {
	if (cmd != 0 and value != 0) {
		cmd = 0;
		resetMIDI();
#if defined(VOLUME_UP) && defined(VOLUME_DOWN)
		if (volume > 0) updateVolume();
#else
		volume = 0;
#endif
	}
}

void setup() {
	pinMode(XCS, OUTPUT);
	digitalWrite(XCS, HIGH);
	pinMode(XDCS, OUTPUT);
	digitalWrite(XDCS, HIGH);
	pinMode(XRESET, OUTPUT);
	digitalWrite(XRESET, HIGH);
#ifdef LED
	pinMode(LED, OUTPUT);
#endif

	SPI.begin();
	SPI.setClockDivider(SPI_CLOCK_DIV8);

	while (!digitalRead(DREQ));

	word i = 0;
	while (i < sizeof plg >> 1) {
		word addr = pgm_read_word_near(&plg[i++]);
		word n = pgm_read_word_near(&plg[i++]);
		if (n & 0x8000U) { // RLE run
			n &= 0x7FFF;
			word val = pgm_read_word_near(&plg[i++]);
			while (n--) writeRegister(addr, val);
		} else // Copy run
			while (n--) writeRegister(addr, pgm_read_word_near(&plg[i++]));
	}

	Serial.begin(115200); // Use instead 57600 for Serial <> MIDI Converter, 38400 for Serial MIDI compatible baud rate, or 31250 for the standard MIDI protocol or USBMidiKliK
}

void loop() {
	while (Serial.available()) {
		byte data = Serial.read();
		if (data >> 5 == 4 or data >> 4 == 11 or data >> 4 == 12 or data >> 4 == 14 or data == 0xF0) {
			cmd = data;
			value = -1;
		} else if (data < 0x80) {
			if (cmd >> 5 == 4 or cmd >> 4 == 11 or cmd >> 4 == 14) {
				if (value < 0) value = data;
				else {
					if (!(cmd >> 4 == 11 and ((value >= 1 and value <= 5) or value == 8 or value == 9 or (value >= 13 and value <= 37) or value == 65 or (value >= 67 and value <= 90) or (value >= 92 and value <= 97) or (value >= 102 and value <= 119) or value == 122 or value == 126 or value == 127))) { // filter out unassigned CCs
						digitalWrite(XDCS, LOW);
						SPI_transfer8bit(cmd);
						SPI_transfer8bit(value);
						SPI_transfer8bit(cmd >> 4 == 8 ? 0 : data);
						digitalWrite(XDCS, HIGH);
					}
					value = -1;
				}
			} else if (cmd >> 5 == 6) {
				digitalWrite(XDCS, LOW);
				SPI_transfer8bit(cmd);
				SPI_transfer8bit(data);
				digitalWrite(XDCS, HIGH);
			} else if (cmd == 0xF0) {
				if (value < MAX_SYSEX_BYTES) sysex[++value] = data;
				else {
					memset(sysex, NULL, sizeof sysex);
					cmd = 0;
				}
			}
		} else if (data == 0xFF) reset();
		else {
			if (data == 0xF7 and cmd == 0xF0) {
				if (sysex[1] == 0x7F) {
					if (sysex[0] == 0x7E and sysex[2] == 9 and (sysex[3] == 1 or sysex[3] == 3) and value == 3) {
						volume = 0;
						resetMIDI();
					} else if (sysex[0] == 0x7F and sysex[2] == 4 and value == 5) {
						if (sysex[3] == 1) {
							volume = 127 - sysex[5];
							updateVolume();
						} else if (sysex[3] == 2) {
							balance = sysex[5] + ((byte)sysex[4] >= 0x40) - 64;
							updateVolume();
						}
					}
				} else if (sysex[0] == 0 and sysex[1] == 1 and sysex[2] == 0x11) {
					if (sysex[3] == 1 and sysex[4] < 4 and value == 4) writeRegisterSplit(0, 8, (sysex[4] & 1) << 4 | (sysex[4] & 2) << 6);
					if (sysex[3] == 2 and value == 5) writeRegisterSplit(2, sysex[5], sysex[4]);
					else if (sysex[3] == 3 and sysex[4] < 0x10 and value == 4) {
						writeRegisterSplit(7, 0x1e, 3);
						writeRegisterSplit(6, 0, sysex[4]);
#ifdef REVERB_TOGGLE
						reverbOff = sysex[4] == 1;
#endif
					}
				}
				memset(sysex, NULL, sizeof sysex);
			}
			cmd = 0;
		}
	}
#ifdef REVERB_TOGGLE
	if (!digitalRead(REVERB_TOGGLE) and !debounce) {
		debounce = true;
#ifdef LED
		digitalWrite(LED, HIGH);
#endif
		reverbOff = !reverbOff;
		writeRegisterSplit(7, 0x1e, 3);
		writeRegisterSplit(6, 0, (byte)reverbOff);
#ifdef LED
		if (!reverbOff) delay(5);
		digitalWrite(LED, LOW);
#endif
	} else
#ifndef RESET
	if (digitalRead(REVERB_TOGGLE) and debounce) debounce = false;
#endif
#endif
#ifdef RESET
	if (!digitalRead(RESET) and !debounce) {
		debounce = true;
#ifdef LED
		digitalWrite(LED, HIGH);
#endif
		reset();
#ifdef LED
		digitalWrite(LED, LOW);
#endif
	} else if (
#ifdef REVERB_TOGGLE
	digitalRead(REVERB_TOGGLE) and 
#endif
	digitalRead(RESET) and debounce) debounce = false;
#endif
#if defined(VOLUME_UP) && defined(VOLUME_DOWN)
	if (!digitalRead(VOLUME_UP) and volume > 0) {
		--volume;
		volumeControl();
	} 
	else if (!digitalRead(VOLUME_DOWN) and volume < 191) {
		++volume;
		volumeControl();
	}
#endif
}